from enum import Enum
from random import shuffle, sample

from constants import RESOURCE
from tile import Tile


def generate_board(mid_row_len: int, top_row_len: int) -> dict:
    """
    Generates the Catan board.

    :param mid_row_len: number of tiles across middle of board
    :param top_row_len: number of tiles across top of board
    :return: a dictionary mapping axial coordinates to Tile objects
    """
    num_tiles = 2 * sum(range(top_row_len, mid_row_len + 1))
    base_chits = [2] + list(range(3, 12)) * 2 + [12]
    chits = base_chits * ((num_tiles // len(base_chits)) + 1)
    shuffle(chits)
    base_resources = [RESOURCE.BRICK, RESOURCE.GRAIN, RESOURCE.LUMBER, RESOURCE.ORE, RESOURCE.WOOL]
    resources = base_resources * ((num_tiles // len(base_resources)) + 1)
    shuffle(resources)
    desert_tiles = set(sample(list(range(num_tiles)), num_tiles // 10))  # 1 desert tile for every 10 tiles
    board = {}
    # keep track of tile index to assign desert tiles
    idx = 0
    # create middle tiles
    tile = Tile(0, 0, resources.pop(), chits.pop()) if idx not in desert_tiles else Tile(0, 0, RESOURCE.NONE, -1)
    idx = idx + 1
    board['0,0'] = tile
    middle_tiles = ['0,0']
    q = 1
    r = 0
    while len(middle_tiles) < mid_row_len:
        end_tile = Tile(q, r, resources.pop(), chits.pop()) \
            if idx not in desert_tiles else Tile(q, r, RESOURCE.NONE, -1)
        idx = idx + 1
        end_tile_coords = str(q) + ',' + str(r)
        start_tile = Tile(-q, r, resources.pop(), chits.pop()) \
            if idx not in desert_tiles else Tile(-q, r, RESOURCE.NONE, -1)
        idx = idx + 1
        start_tile_coords = str(-q) + ',' + str(r)
        board[end_tile_coords] = end_tile
        board[start_tile_coords] = start_tile
        middle_tiles.append(end_tile_coords)
        middle_tiles.insert(0, start_tile_coords)
        q = q + 1
    curr_row = middle_tiles
    # add tiles above, offset to the right
    # add 1 to q, subtract 1 from r
    while len(curr_row) > top_row_len:
        temp_row = []
        for i in range(len(curr_row) - 1):
            el = curr_row[i]
            tokens = el.split(',')
            q = int(tokens[0]) + 1
            r = int(tokens[1]) - 1
            new_key = str(q) + ',' + str(r)
            new_tile = Tile(q, r, resources.pop(), chits.pop()) \
                if idx not in desert_tiles else Tile(q, r, RESOURCE.NONE, -1)
            idx = idx + 1
            board[new_key] = new_tile
            temp_row.append(new_key)
            # mirrored tile
            q_bottom = q + r
            r_bottom = -r
            s_bottom = -q
            new_key_bottom = str(q_bottom) + ',' + str(r_bottom)
            new_tile_bottom = Tile(q_bottom, r_bottom, resources.pop(), chits.pop()) \
                if idx not in desert_tiles else Tile(q_bottom, r_bottom, RESOURCE.NONE, -1)
            board[new_key_bottom] = new_tile_bottom
        curr_row = temp_row
    return board


def generate_vertices(board: dict) -> dict:
    """
    Adds Vertex objects to the board's Tile objects.

    :param board: The tile dictionary generated by generate_board.
    :return: The dictionary with updated Tile objects
    """


class Board:

    def __init__(self, mid_row_len: int, top_row_len: int) -> None:
        self.board = generate_board(mid_row_len, top_row_len)
